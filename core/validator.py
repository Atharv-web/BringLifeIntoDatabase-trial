import re, sqlparse
from typing import Dict,Any, List, Optional
import logging 

logger = logging.getLogger(__name__)

FORBIDDEN_PATTERNS = [
    r'\bDROP\s+TABLE\b',
    r'\bDROP\s+DATABASE\b',
    r'\bDROP\s+SCHEMA\b',
    r'\bTRUNCATE\b',
    r'\bDELETE\s+FROM\s+\w+\s*;',
    r'\bREVOKE\b',
    r'\bGRANT\b',
    r'\bSHUTDOWN\b',
    r'\bCOPY\s+.+\s+FROM\s+PROGRAM\b',
    r';.*;\s*'
]

DML_SAFETY_COMMANDS = {"UPDATE","DELETE"}

ALLOWED_DDL = {'CREATE INDEX','VACUUM','ANALYZE','CREATE TABLE'}

ALLOWED_HYPERTABLES = {
    'schema_metadata',
    'query_performance',
    'index_analytics',
    'table_statistics',
    'semantic_relationships',
    'system_health',
    'data_quality_metrics',
    'agent_actions'
}

class SqlValidationError(Exception):
    pass

class SqlValidator:
    """multilayer safety checks for sql queries generated by agent"""

    def __init__(self):
        self._forbidden_regex = [re.compile(pattern,re.IGNORECASE) for pattern in FORBIDDEN_PATTERNS]
        self._ddl_regex = re.compile(r'^\s*(CREATE|ALTER|DROP|TRUNCATE)\b',re.IGNORECASE)
        self._first_token_regex = re.compile(r'^\s*([A-Z]+)',re.IGNORECASE)

    def _get_command(self,sql:str) -> Optional[str]:
        """return the first significant sql command token(uppercased in this scenario) or None. """
        parsed = sqlparse.parse(sql)
        if not parsed:
            return None
        
        for token in parsed[0].tokens:
            val = token.value.strip()
            if val:
                m = self._first_token_regex.match(val)
                if m:
                    return m.group(1).upper()

        return None

    def _matches_forbidden(self,sql:str) -> List[str]:
        """return list of matching forbidden patterns (empty if none.)"""
        hits =[]
        for rgx in self._forbidden_regex:
            if rgx.search(sql):
                hits.append(rgx.pattern)
        return hits

    def _requires_where(self,sql:str) -> bool:
        """return true if update/delete without where appears unsafe."""
        cmd = self._get_command(sql)
        if cmd in DML_SAFETY_COMMANDS:
            return "WHERE" not in sql.upper()
        return False

    async def _table_exists(self,db,table_name:str, schema:str = None, target:str="postgres") -> bool:
        """check the information schema, if the table exists or not."""
        
        if schema is None:
            schema = "public" if target == "postgres" else "_agentic"
        
        query = """SELECT EXISTS (
        SELECT 1 from information_schema.tables WHERE table_schema = $1 and table_name = $2)"""

        try:
            if target == "postgres":
                result = await db.fetchval_pg_db(query,schema,table_name)
            else:
                result = await db.fetchval_ts_db(query,schema,table_name)
            return bool(result)

        except Exception as e:
            logger.error(f"Error checking table existence: {e}")
            return False
    
    async def _column_exists(self, db, table_name: str, column_name: str, schema: str = None, target: str = "postgres") -> bool:
        """"""

        if schema is None:
            schema = "public" if target == "postgres" else "_agentic"
        
        query = """
        SELECT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_schema = $1 AND table_name = $2 AND column_name = $3
        );
        """

        try:
            if target == "postgres":
                result = await db.fetchval_pg_db(query,schema,table_name,column_name)
            else:
                result = await db.fetchval_ts_db(query,schema,table_name,column_name)
            return bool(result)

        except Exception as e:
            logger.error(f"Error checking column existence: {e}")
            return False


    def _extract_create_index_parts(self, sql: str) -> Optional[Dict[str, str]]:
        """
        Attempt to extract index_name, table_name, column_name from simple CREATE INDEX statements.
        Returns dict or None if extraction failed.
        Note: This is conservative and supports patterns like:
            CREATE INDEX IF NOT EXISTS idx_name ON schema.table(col1, col2);
        """
        # Normalize whitespace
        s = re.sub(r'\s+', ' ', sql).strip()
        # basic regex
        m = re.search(r'CREATE\s+INDEX(?:\s+IF\s+NOT\s+EXISTS)?\s+([^\s]+)\s+ON\s+([^\s(]+)\s*\(([^)]+)\)', s, re.IGNORECASE)
        
        if not m:
            return None
        
        index_name = m.group(1)
        table_name = m.group(2)
        cols_raw = m.group(3)
        
        # only take first column for safety checks; store as list
        cols = [c.strip() for c in cols_raw.split(',') if c.strip()]
        first_col = cols[0] if cols else None
        
        schema = "public"
        # strip schema if present (schema.table)
        if '.' in table_name:
            schema, table_name = table_name.split('.', 1)
        return {
            "index_name": index_name, 
            "table_name": table_name,
            "schema": schema, 
            "columns": cols, 
            "first_column": first_col
        }

    def _extract_insert_table(self, sql: str) -> Optional[Dict[str, str]]:
        """Extract table name and schema from INSERT statement."""
        m = re.search(r'INSERT\s+INTO\s+([^\s(]+)', sql, re.IGNORECASE)
        if m:
            table = m.group(1)
            schema = "public"
            if '.' in table:
                schema, table = table.split('.', 1)
            return {"table_name": table, "schema": schema}
        return None

    def _validate_hypertable_target(self, table_name: str) -> bool:
        """Ensure INSERTs only go to allowed hypertables."""
        return table_name in ALLOWED_HYPERTABLES

    async def explain_plan(self, db, sql: str, target: str = "postgres") -> Optional[str]:
        """
        Run EXPLAIN (no ANALYZE) for SELECT queries to get a plan.
        Returns the textual plan or None if not applicable.
        """
        cmd = self._get_command(sql)
        if not cmd or cmd != "SELCT":
            return None

        explain_sql = f"EXPLAIN {sql}"

        try:
            if target == "postgres":
                rows = await db.fetch_pg_db(explain_sql)
            else:
                rows = await db.fetch_ts_db(explain_sql)

            lines = [row['QUERY PLAN'] for row in rows]
            return "\n".join(lines)
        except Exception as e:
            logger.error(f"EXPLAIN failed: {e}")
            return f"EXPLAIN failed: {e}"

    async def validate(self, sql: str, db, target: str = "postgres") -> Dict[str, Any]:
        """
        Run a full validation pass and return a structured result:
        {
            "ok": bool,
            "errors": [list of reasons],
            "warnings": [list],
            "command": "SELECT"/"CREATE"/...,
            "explain": "..." (optional)
        }
        """
        result: Dict[str, Any] = {
            "ok": True, 
            "errors": [], 
            "warnings": [], 
            "command": None, 
            "explain": None
        }

        if not sql or not sql.strip():
            result["ok"] = False
            result["errors"].append("Empty SQL provided.")
            return result

        # 1) Basic parse & command extraction
        try:
            parsed = sqlparse.format(sql, reindent=False, keyword_case='upper')
            cmd = self._get_command(parsed)
            result["command"] = cmd
            
            if not cmd:
                result["ok"] = False
                result["errors"].append("Could not determine SQL command.")
                return result
        
        except Exception as e:
            result["ok"] = False
            result["errors"].append(f"SQL parse error: {e}")
            return result

        # 2) Forbidden patterns
        forbidden_hits = self._matches_forbidden(sql)
        if forbidden_hits:
            result["ok"] = False
            result["errors"].append(f"Forbidden SQL patterns detected: {forbidden_hits}")
            return result

        # 3) DML safety: require WHERE on UPDATE/DELETE
        if self._requires_where(sql):
            result["ok"] = False
            result["errors"].append("Unsafe DML detected: UPDATE/DELETE without WHERE is not allowed.")
            return result

        # 4) Validate Insert for tigerdata
        if cmd == "INSERT" and target == "timescale":
            insert_parts = self._extract_insert_table(sql)
            if insert_parts:
                table = insert_parts["table_name"]
                if not self._validate_hypertable_target(table):
                    result["ok"] = False
                    result["errors"].append(f"INSERT to '{table}' not allowed. Only known hypertables permitted.")
                    return result

        # 5) DDL/DDL-like safety checks (CREATE INDEX etc)
        # For CREATE INDEX, confirm referenced table and columns exist
        if cmd == "CREATE":
            # crude check: is this a CREATE INDEX?
            if re.search(r'CREATE\s+INDEX', sql, re.IGNORECASE):
                parts = self._extract_create_index_parts(sql)
                
                if not parts:
                    result["ok"] = False
                    result["errors"].append("Unable to parse CREATE INDEX statement or unsupported pattern.")
                    return result
                
                table = parts["table_name"]
                col = parts["first_column"]
                schema = parts["schema"]

                # check table exists in Postgres
                table_exists = await self._table_exists(db, table, schema=schema, target=target)
                if not table_exists:
                    result["ok"] = False
                    result["errors"].append(f"Referenced table '{schema}.{table}' does not exist in.")
                    return result
                # check column exists
                col_exists = await self._column_exists(db, table, col, schema=schema, target=target)
                if not col_exists:
                    result["ok"] = False
                    result["errors"].append(f"Referenced column '{col}' does not exist in table '{table}'.")
                    return result
                # safe for index creation if passed above
            else:
                # For other CREATEs, reject unless explicit allow
                if not any(k in sql.upper() for k in ALLOWED_DDL):
                    result["ok"] = False
                    result["errors"].append("DDL operation not explicitly allowed by validator.")
                    return result

        # 6) SELECT explain plan for additional confidence
        if cmd == "SELECT":
            explain = await self.explain_plan(db, sql, target=target)
            result["explain"] = explain
            # optionally add heuristic checks on the plan (e.g., seq scan warnings)
            if explain and "Seq Scan" in explain:
                result["warnings"].append("EXPLAIN shows Seq Scan(s); consider indexing or rewriting the query.")

        # 7) Final: if no errors, ok True
        result["ok"] = len(result["errors"]) == 0
        return result

    async def is_safe_to_execute(self, sql: str, db, target: str = "postgres") -> bool:
        """Simple boolean check for agents."""
        result = await self.validate(sql, db, target)
        return result["ok"]

    async def validate_and_explain(self, sql: str, db, target: str = "postgres") -> str:
        """Human-readable validation result."""
        result = await self.validate(sql, db, target)
        
        if result["ok"]:
            msg = f"âœ… SQL is safe to execute.\nCommand: {result['command']}"
            if result.get("warnings"):
                msg += f"\n Warnings: {', '.join(result['warnings'])}"
            if result.get("explain"):
                msg += f"\n\nğŸ“Š Execution Plan:\n{result['explain']}"
            return msg
        else:
            msg = f"âŒ SQL validation FAILED.\nCommand: {result['command']}"
            msg += f"\n Errors: {', '.join(result['errors'])}"
            return msg